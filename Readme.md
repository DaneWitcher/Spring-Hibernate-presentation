Spring boot crud example

**Задача №1 Создать приложение crud на spring boot**
    Скачиваем через мавен все нужные пакеты, которые будут совместимы с друг другом.
    Создаем Restcontroller(UserController), Service(UserSerice), Repository (UserDAO), Model(User).
    Прописываем в application.properties данные для подключения к БД MySQL.
    Создаем класс Application и прописываем точку входа в Spring boot.
    Все конфигурации за нас сделает Spring Boot.

**Задача №2 создать бины и внедрить зависимости**
    Бины создаются с помощью аннотации над классами(UserController, Admin, UserServiceImpl, UserDAOJDBCImpl, UserDAOHibernateImpl). 
    Внедрить зависимость можно через поле(15-16 строка), либо сеттер(убираем 15 и включаем 23-26) или конструктор(убираем 15 и влючаем 18-21) - реализовано в классе UserController.
        
**Задача №3 Жизненный цикл бина** 
    При запуске приложения (через класс Application) Application context проходит по всем пакетам приложения(В Spring Boot автоматический ComponentScan), создаются объекты классов, где есть аннотации бинов,для каждого бина запускается BeanPostproccesor, затем запускается метод init() и бин переходит под управление пользователя. 
    Когда выключаем приложение - у каждого бина последовательно запускается метод destroy() и только после этого приложение отключается
        
**Задача №4 Создать свою собтсвенную аннотацию и передать параметр в бин**
    Создаем интерфейс Username, над ним ставим аннотацию Retention и в ней значение ставим Runtime(кроме этого есть Class(скомпилируется, но мы не сможем с ней взаимодействовать) и SOURCE (не скомпилируется) ) и создаем один параметр name.
    В классе Admin над полем username ставим нашу аннотацию и передаем значение admin.
    Создаем класс UsernameBeanPostProcessor, реализуем интерфейс BeanPostProcessor и 2 метода. В методе postProcessBeforeInitialization находим все поля с аннотацикй username, для каждого поля присваиваем значение, которое передавалось в параметре через Рефлексию(пакет ReflectionUtils в спринге).

**Задача №5 создать аннотацию , с помощью которой можно будет замерять время работы метода в рантайм**     
    Создаем интрейфейс Timer, над ним ставим аннотацию Retention и в ней значение ставим Runtime.
    В классе Admin над методом ставим нашу аннотацию.
    Создаем класс TimerBeanPostProcessor, реализуем интерфейс BeanPostProcessor и 2 метода.
    На 16 строке создаем hashmap где будем хранить классы с нашей аннотацией.
    В методе postProcessBeforeInitialization классы, где есть наша аннотация, кладем в мапу по имени бина(имя не меняется в runtime).
    В методе postProcessAfterInitialization из мапы достаем классы, оборачиваем прокси, которая перед запуском и после окончания работы метода засекает время и выводит время действия метода.

**Задача №6 Проверить жизненный цикл бина при Scope Singleton(по умолчанию) и Prototype**
    на 9 строке класса Admin прописываем Scope prototype. 
    Ставим метки для дебагера на 16 и 21 строке (конструктор класса и init метод ) и на любом методе BeanPostProcessor.
    Запускаем приложение и видим, что бин не создается на старте - он будет создаватся при каждом запросе данного бина.

**Задача №7 Реализовать работу с БД 2 способами через Hibernate и JBDC и указать предпочтительный способ через Hibernate (2 способа)**        
    Реализовываем 2 класса. 
    В каждом классе в аннотации @Repository пишем значение параметра.
    В классе UserServiceImpl. где внедряем зависимость над полем пишем аннотацию @Qualifier и пишем реализацию(Hibernate) которую хотим использовать. 
    Второй способ: над классом UserDAOHibernateImpl пишем аннотацию @Primary (13 строка). 
    
**Задача №8 Упростить сущность User с помощью плагина, чтобы не писать конструкторы, геттеры, сеттеры, hashcode и equals.**
    Скачиваем через maven плагин lombok.
    С помощью него над сущностью User пишем нужные аннотации. 